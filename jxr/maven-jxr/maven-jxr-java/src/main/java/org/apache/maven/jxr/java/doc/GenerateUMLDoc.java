package org.apache.maven.jxr.java.doc;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.GregorianCalendar;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.TimeZone;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.maven.jxr.util.DotUtil;
import org.apache.maven.jxr.util.DotUtil.DotNotPresentInPathException;
import org.codehaus.plexus.logging.AbstractLogEnabled;
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.IOUtil;
import org.codehaus.plexus.util.StringUtils;
import org.codehaus.plexus.util.cli.CommandLineException;

import com.sun.tools.javadoc.Main;

/**
 * Generate UML diagram from Java source directory.
 * <br/>
 * <b>Note</b>: <a href="http://www.graphviz.org/">Graphviz</a> dot program should be in the path or specified
 * by <code>dotExecutable</code> parameter.
 *
 * @author <a href="mailto:vincent.siveton@gmail.com">Vincent Siveton</a>
 * @version $Id$
 * @plexus.component role="org.apache.maven.jxr.java.doc.UmlDoc" role-hint="default"
 */
public class GenerateUMLDoc
    extends AbstractLogEnabled
    implements UmlDoc
{
    private static final String NOW = new GregorianCalendar( TimeZone.getDefault() ).getTime().toString();

    /** Source directory */
    private File srcDir;

    /** Source file encoding name, ISO-8859-1 is the default. */
    private String encoding = "ISO-8859-1";

    /** Output file of the diagram */
    private File out;

    /** Graphviz Dot executable file */
    private File dotExecutable;

    /** The class diagram encoding, ISO-8859-1 is the default. */
    private String diagramEncoding = "ISO-8859-1";

    /** The class diagram label */
    private String diagramLabel = "Class Diagram (Generated by Maven on " + NOW + ")";

    /** Relative path or URI to the generated Javadoc directory. */
    private String javadocPath = "";

    /** Relative path or URI to the generated Java Xref directory. */
    private String javasrcPath = "";

    /** Temp XSL file. */
    private File xml2dot;

    /** Temp javadoc xml file */
    private File javadocXml;

    /** Temp generated dot file */
    private File dot;

    /**
     * Specifies the access level for classes and members to show in the generated class diagram.
     * Possible values are:
     * <ul>
     * <li>public: shows only public classes and members</li>
     * <li>protected: shows only public and protected classes and members</li>
     * <li>package: shows all classes and members not marked private</li>
     * <li>private: shows all classes and members</li>
     * <li>"" (i.e. empty): nothing</li>
     * </ul>
     *
     * Default value is protected.
     */
    private String show = "protected";

    /** Specify verbose information */
    private boolean verbose;

    // ----------------------------------------------------------------------
    // Public
    // ----------------------------------------------------------------------

    /** {@inheritDoc} */
    public void generate( File aSrcDir, File theOut )
        throws IllegalArgumentException, DotNotPresentInPathException, IOException, UmlDocException
    {
        generate( aSrcDir, null, theOut, null );
    }

    /** {@inheritDoc} */
    public void generate( File aSrcDir, String srcEncoding, File theOut, String outEncoding )
        throws IllegalArgumentException, DotNotPresentInPathException, IOException, UmlDocException
    {
        if ( aSrcDir == null )
        {
            throw new IllegalArgumentException( "Missing mandatory attribute 'srcDir'." );
        }
        if ( !aSrcDir.exists() || aSrcDir.isFile() )
        {
            throw new IOException( "Input '" + aSrcDir + "' not found or not a directory." );
        }

        if ( theOut == null )
        {
            throw new IllegalArgumentException( "Missing mandatory attribute 'out'." );
        }
        if ( theOut.exists() && theOut.isDirectory() )
        {
            throw new IOException( theOut + " is a directory." );
        }
        if ( !theOut.exists() && !theOut.getParentFile().exists() && !theOut.getParentFile().mkdirs() )
        {
            throw new IOException( "Cannot create the parent directory of " + theOut );
        }

        this.srcDir = aSrcDir;
        this.out = theOut;

        if ( !StringUtils.isEmpty( srcEncoding ) )
        {
            if ( validateEncoding( srcEncoding ) )
            {
                this.encoding = srcEncoding;
            }
            else
            {
                getLogger().info( "Unsupported Character Encoding for " + srcEncoding + ". IGNORED" );
            }
        }
        if ( !StringUtils.isEmpty( outEncoding ) )
        {
            if ( validateEncoding( outEncoding ) )
            {
                this.diagramEncoding = outEncoding;
            }
            else
            {
                getLogger().info( "Unsupported Character Encoding for " + outEncoding + ". IGNORED" );
            }
        }

        // 1. Generate Javadoc xml
        generateJavadocXML();

        // 2. Generate dot image
        try
        {
            generateJavadocDot();
        }
        catch ( TransformerException e )
        {
            throw new UmlDocException( "TransformerException: " + e.getMessage() );
        }

        // 3. Generate UML image
        try
        {
            generateUmlImage();
        }
        catch ( CommandLineException e )
        {
            throw new UmlDocException( "CommandLineException: " + e.getMessage() );
        }

        if ( !isVerbose() )
        {
            // 4. Remove the generated DTD
            File dtd = new File( getJavadocXml().getParentFile(), XMLDoclet.XMLDOCLET_DTD );
            if ( !dtd.delete() )
            {
                throw new IOException( "Can't delete the generated DTD file: " + dtd );
            }
        }
    }

    /** {@inheritDoc} */
    public void generate( File graphExecutable, File aSrcDir, String srcEncoding, File theOut, String outEncoding )
        throws IllegalArgumentException, DotNotPresentInPathException, IOException, UmlDocException
    {
        if ( dotExecutable == null )
        {
            throw new IllegalArgumentException( "Missing mandatory attribute 'dotExecutable'." );
        }
        if ( !dotExecutable.exists() || !dotExecutable.isFile() )
        {
            throw new IOException( "Input '" + dotExecutable + "' not found or not a file." );
        }
        this.dotExecutable = graphExecutable;

        generate( aSrcDir, srcEncoding, theOut, outEncoding );
    }

    /** {@inheritDoc} */
    public void setDiagramLabel( String diagramLabel )
    {
        this.diagramLabel = diagramLabel;
    }

    /** {@inheritDoc} */
    public void setJavadocPath( String javadocPath )
    {
        this.javadocPath = javadocPath;
    }

    /** {@inheritDoc} */
    public void setJavasrcPath( String javasrcPath )
    {
        this.javasrcPath = javasrcPath;
    }

    /** {@inheritDoc} */
    public void setShow( String show )
    {
        this.show = show;
    }

    // ----------------------------------------------------------------------
    // Protected
    // ----------------------------------------------------------------------

    /**
     * Setter for the verbose. Used by Ant task
     *
     * @param verbose the verbose to set
     */
    protected void setVerbose( boolean verbose )
    {
        this.verbose = verbose;
    }

    // ----------------------------------------------------------------------
    // Private
    // ----------------------------------------------------------------------

    /**
     * Getter for the diagramEncoding
     *
     * @return the diagramEncoding
     */
    private String getDiagramEncoding()
    {
        return this.diagramEncoding;
    }

    /**
     * Getter for the diagramLabel
     *
     * @return the diagramLabel
     */
    private String getDiagramLabel()
    {
        return this.diagramLabel;
    }

    /**
     * Getter for the dotExecutable
     *
     * @return the dotExecutable
     */
    private File getDotExecutable()
    {
        return this.dotExecutable;
    }

    /**
     * Getter for the encoding
     *
     * @return the encoding
     */
    private String getEncoding()
    {
        return this.encoding;
    }

    /**
     * Getter for the javadocPath
     *
     * @return the relative path or URI to the generated javadoc directory
     */
    private String getJavadocPath()
    {
        return this.javadocPath;
    }

    /**
     * Getter for the javasrcPath
     *
     * @return the relative path or URI to the generated javasrc directory
     */
    private String getJavasrcPath()
    {
        return this.javasrcPath;
    }

    /**
     * Getter for the destDir
     *
     * @return the destDir
     */
    private File getOut()
    {
        return this.out;
    }

    /**
     * Getter for the show. Possible values are:
     * <ul>
     * <li>public: shows only public classes and members</li>
     * <li>protected: shows only public and protected classes and members</li>
     * <li>package: shows all classes and members not marked private</li>
     * <li>private: shows all classes and members</li>
     * <li>"" (i.e. empty): nothing</li>
     * </ul>
     *
     * @return the show
     */
    private String getShow()
    {
        return this.show;
    }

    /**
     * Getter for the verbose
     *
     * @return the verbose
     */
    private boolean isVerbose()
    {
        if ( getLogger() != null ) // for Ant tasks
        {
            return !getLogger().isInfoEnabled();
        }

        return this.verbose;
    }

    /**
     * @return the javadoc output xml file
     */
    private File getJavadocXml()
    {
        if ( this.javadocXml == null )
        {
            this.javadocXml = new File( getOut().getParentFile(), FileUtils.removeExtension( getOut().getName() )
                + ".javadoc.xml" );
            if ( !isVerbose() )
            {
                this.javadocXml.deleteOnExit();
            }
        }

        return this.javadocXml;
    }

    /**
     * @return a temp file for dot file.
     */
    private File getDot()
    {
        if ( this.dot == null )
        {
            this.dot = new File( getOut().getParentFile(), FileUtils.removeExtension( getOut().getName() )
                + ".javadoc.dot" );
            if ( !isVerbose() )
            {
                this.dot.deleteOnExit();
            }
        }

        return this.dot;
    }

    /**
     * @return the xml2dot XSL file.
     * @throws IOException if any
     */
    private File getXml2dot()
        throws IOException
    {
        if ( this.xml2dot == null )
        {
            this.xml2dot = new File( getOut().getParentFile(), FileUtils.removeExtension( getOut().getName() )
                + ".xml2dot.xsl" );
            if ( !isVerbose() )
            {
                this.xml2dot.deleteOnExit();
            }

            InputStream is = getClass().getClassLoader().getResourceAsStream(
                                                                              GenerateUMLDoc.class.getPackage()
                                                                                  .getName().replace( ".", "/" )
                                                                                  + "/xml2dot.xsl" );
            if ( is == null )
            {
                throw new IOException( "This resource doesn't exist." );
            }

            FileOutputStream w = new FileOutputStream( this.xml2dot );

            IOUtil.copy( is, w );

            IOUtil.close( is );

            IOUtil.close( w );
        }

        return this.xml2dot;
    }

    /**
     * Call javadoc tool with the XMLDoclet
     *
     * @throws IOException if Javadoc error
     */
    private void generateJavadocXML()
        throws IOException
    {
        final String defaultExcludes = "**/*~,**/#*#,**/.#*,**/%*%,**/._*,**/CVS,**/CVS/**,"
            + "**/.cvsignore,**/SCCS,**/SCCS/**,**/vssver.scc,**/.svn,**/.svn/**,**/.DS_Store";

        List args = new LinkedList();
        args.add( "-private" );
        args.add( "-sourcepath" );
        args.add( srcDir.getAbsolutePath() );
        if ( StringUtils.isNotEmpty( getEncoding() ) )
        {
            args.add( "-encoding" );
            args.add( getEncoding() );
            args.add( "-xmlencoding" );
            args.add( getEncoding() );
        }
        args.add( "-o" );
        args.add( getJavadocXml().getAbsolutePath() );
        List packages = FileUtils.getDirectoryNames( srcDir, null, defaultExcludes, false );
        for ( Iterator it = packages.iterator(); it.hasNext(); )
        {
            String p = (String) it.next();

            if ( StringUtils.isEmpty( p ) )
            {
                continue;
            }

            if ( FileUtils.getFileNames( new File( srcDir, p ), "*.java", "", false ).isEmpty() )
            {
                continue;
            }

            args.add( StringUtils.replace( p, File.separator, "." ) );
        }

        StringWriter err = new StringWriter();
        StringWriter warn = new StringWriter();
        StringWriter notice = new StringWriter();

        ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();
        try
        {
            Thread.currentThread().setContextClassLoader( XMLDoclet.class.getClassLoader() );
            int exit = Main.execute( "javadoc", new PrintWriter( err ), new PrintWriter( warn ),
                                     new PrintWriter( notice ), XMLDoclet.class.getName(), (String[]) args
                                         .toArray( new String[0] ) );

            if ( exit != 0 )
            {
                throw new IOException( "Error when calling Javadoc: " + err );
            }
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( currentClassLoader );
        }
    }

    /**
     * Apply XSLT to generate dot file from the Javadoc xml
     *
     * @throws IOException if any
     * @throws TransformerException if any
     */
    private void generateJavadocDot()
        throws IOException, TransformerException
    {
        SAXTransformerFactory transformerFactory = (SAXTransformerFactory) TransformerFactory.newInstance();
        if ( !( transformerFactory.getFeature( javax.xml.transform.sax.SAXSource.FEATURE ) && transformerFactory
            .getFeature( javax.xml.transform.stream.StreamResult.FEATURE ) ) )
        {

            throw new TransformerException( "The supplied TrAX transformer library is inadeguate."
                + "Please upgrade to the latest version." );
        }

        Transformer serializer = transformerFactory.newTransformer( new StreamSource( getXml2dot() ) );

        if ( StringUtils.isNotEmpty( getDiagramEncoding() ) )
        {
            serializer.setOutputProperty( OutputKeys.ENCODING, getDiagramEncoding() );
        }

        serializer.setParameter( "now", NOW );
        serializer.setParameter( "diagramEncoding", ( getDiagramEncoding() == null ? "" : getDiagramEncoding() ) );
        serializer.setParameter( "show", ( getShow() == null ? "" : getShow() ) );
        if ( ( StringUtils.isNotEmpty( getJavasrcPath() ) )
            && ( !"/".equals( getJavasrcPath().substring( getJavasrcPath().length() - 1 ) ) ) )
        {
            setJavasrcPath( getJavasrcPath() + "/" );
        }
        serializer.setParameter( "javasrcPath", ( getJavasrcPath() == null ? "" : getJavasrcPath() ) );
        if ( ( StringUtils.isNotEmpty( getJavadocPath() ) )
            && ( !"/".equals( getJavadocPath().substring( getJavadocPath().length() - 1 ) ) ) )
        {
            setJavadocPath( getJavadocPath() + "/" );
        }
        serializer.setParameter( "javadocPath", ( getJavadocPath() == null ? "" : getJavadocPath() ) );
        serializer.setParameter( "diagramLabel", ( getDiagramLabel() == null ? "" : getDiagramLabel() ) );

        serializer.transform( new StreamSource( getJavadocXml() ), new StreamResult( getDot() ) );
    }

    /**
     * Call Graphviz dot to generate images.
     *
     * @throws CommandLineException if any
     * @throws DotNotPresentInPathException if any
     */
    private void generateUmlImage()
        throws CommandLineException, DotNotPresentInPathException
    {
        String outputPath = getOut().getAbsolutePath();
        String format;
        if ( outputPath.lastIndexOf( "." ) != -1 )
        {
            format = outputPath.substring( outputPath.lastIndexOf( "." ) + 1 );
        }
        else
        {
            format = "svg";
        }

        if ( getDotExecutable() == null )
        {
            DotUtil.executeDot( getDot(), getOut() );
        }
        else
        {
            DotUtil.executeDot( getDotExecutable(), getDot(), getOut() );
        }
    }

    /**
     * Validate if a charset is supported on this platform.
     *
     * @param charsetName the charsetName to be check.
     */
    private static boolean validateEncoding( String charsetName )
    {
        if ( StringUtils.isEmpty( charsetName ) )
        {
            return false;
        }

        OutputStream ost = new ByteArrayOutputStream();
        OutputStreamWriter osw = null;
        try
        {
            osw = new OutputStreamWriter( ost, charsetName );
        }
        catch ( UnsupportedEncodingException exc )
        {
            return false;
        }
        finally
        {
            try
            {
                if ( osw != null )
                {
                    osw.close();
                }
            }
            catch ( IOException exc )
            {
                //nop
            }
        }
        return true;
    }
}
