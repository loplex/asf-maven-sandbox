package org.apache.maven.jxr.java.doc;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.GregorianCalendar;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.TimeZone;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.maven.jxr.util.DotUtil;
import org.apache.maven.jxr.util.DotUtil.DotNotPresentInPathException;
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.IOUtil;
import org.codehaus.plexus.util.StringUtils;
import org.codehaus.plexus.util.cli.CommandLineException;

import com.sun.tools.javadoc.Main;

/**
 * Generate UML diagram from Java source directory.
 * <br/>
 * <b>Note</b>: <a href="http://www.graphviz.org/">Graphviz</a> dot program should be in the path or specified
 * by <code>dotExecutable</code> parameter.
 *
 * @author <a href="mailto:vincent.siveton@gmail.com">Vincent Siveton</a>
 * @version $Id$
 */
public class GenerateUMLDoc
{
    private static final String NOW = new GregorianCalendar( TimeZone.getDefault() ).getTime().toString();

    /** Source directory */
    private File srcDir;

    /** Source file encoding name, ISO-8859-1 is the default. */
    private String encoding = "ISO-8859-1";

    /** Output file of the diagram */
    private File out;

    /** Graphviz Dot executable file */
    private File dotExecutable;

    /** The class diagram encoding, ISO-8859-1 is the default. */
    private String diagramEncoding = "ISO-8859-1";

    /** The class diagram label */
    private String diagramLabel = "Class Diagram (Generated by Maven on " + NOW + ")";

    /** Relative path or URI to the generated Javadoc directory. */
    private String javadocPath = "";

    /** Relative path or URI to the generated Java Xref directory. */
    private String javasrcPath = "";

    /** Temp XSL file. */
    private File xml2dot;

    /** Temp javadoc xml file */
    private File javadocXml;

    /** Temp generated dot file */
    private File dot;

    /**
     * Specifies the access level for classes and members to show in the generated class diagram.
     * Possible values are:
     * <ul>
     * <li>public: shows only public classes and members</li>
     * <li>protected: shows only public and protected classes and members</li>
     * <li>package: shows all classes and members not marked private</li>
     * <li>private: shows all classes and members</li>
     * <li>"" (i.e. empty): nothing</li>
     * </ul>
     *
     * Default value is protected.
     */
    private String show = "protected";

    /** Specify verbose information */
    private boolean verbose;

    /**
     * Default constructor.
     *
     * @param srcDir not null
     * @param out not null
     * @throws IllegalArgumentException if any
     */
    public GenerateUMLDoc( File srcDir, File out )
        throws IllegalArgumentException
    {
        if ( srcDir == null )
        {
            throw new IllegalArgumentException( "Missing mandatory attribute 'srcDir'." );
        }
        if ( !srcDir.exists() || srcDir.isFile() )
        {
            throw new IllegalArgumentException( "Input '" + srcDir + "' not found or not a directory." );
        }

        if ( out == null )
        {
            throw new IllegalArgumentException( "Missing mandatory attribute 'out'." );
        }
        if ( out.exists() && out.isDirectory() )
        {
            throw new IllegalArgumentException( out + " is a directory." );
        }
        if ( !out.exists() && !out.getParentFile().exists() && !out.getParentFile().mkdirs() )
        {
            throw new IllegalArgumentException( "Cannot create the parent directory of " + out );
        }

        this.srcDir = srcDir;
        this.out = out;
    }

    /**
     * Generate the documentation
     *
     * @throws UmlDocException if any
     * @throws DotNotPresentInPathException if any
     */
    public void generateUML()
        throws UmlDocException, DotNotPresentInPathException
    {
        // 1. Generate Javadoc xml
        try
        {
            generateJavadocXML();
        }
        catch ( IOException e )
        {
            throw new UmlDocException( "IOException: " + e.getMessage() );
        }

        // 2. Generate dot image
        try
        {
            generateJavadocDot();
        }
        catch ( IOException e )
        {
            throw new UmlDocException( "IOException: " + e.getMessage() );
        }
        catch ( TransformerException e )
        {
            throw new UmlDocException( "TransformerException: " + e.getMessage() );
        }

        // 3. Generate UML image
        try
        {
            generateUmlImage();
        }
        catch ( CommandLineException e )
        {
            throw new UmlDocException( "CommandLineException: " + e.getMessage() );
        }

        if ( !isVerbose() )
        {
            // 4. Remove the generated DTD
            File dtd = new File( getJavadocXml().getParentFile(), XMLDoclet.XMLDOCLET_DTD );
            if ( !dtd.delete() )
            {
                throw new UmlDocException( "IOException: can't delete the generated DTD file: " + dtd );
            }
        }
    }

    /**
     * Getter for the diagramEncoding
     *
     * @return the diagramEncoding
     */
    public String getDiagramEncoding()
    {
        return this.diagramEncoding;
    }

    /**
     * Getter for the diagramLabel
     *
     * @return the diagramLabel
     */
    public String getDiagramLabel()
    {
        return this.diagramLabel;
    }

    /**
     * Getter for the dotExecutable
     *
     * @return the dotExecutable
     */
    public File getDotExecutable()
    {
        return this.dotExecutable;
    }

    /**
     * Getter for the encoding
     *
     * @return the encoding
     */
    public String getEncoding()
    {
        return this.encoding;
    }

    /**
     * Getter for the javadocPath
     *
     * @return the relative path or URI to the generated javadoc directory
     */
    public String getJavadocPath()
    {
        return this.javadocPath;
    }

    /**
     * Getter for the javasrcPath
     *
     * @return the relative path or URI to the generated javasrc directory
     */
    public String getJavasrcPath()
    {
        return this.javasrcPath;
    }

    /**
     * Getter for the destDir
     *
     * @return the destDir
     */
    public File getOut()
    {
        return this.out;
    }

    /**
     * Getter for the show. Possible values are:
     * <ul>
     * <li>public: shows only public classes and members</li>
     * <li>protected: shows only public and protected classes and members</li>
     * <li>package: shows all classes and members not marked private</li>
     * <li>private: shows all classes and members</li>
     * <li>"" (i.e. empty): nothing</li>
     * </ul>
     *
     * @return the show
     */
    public String getShow()
    {
        return this.show;
    }

    /**
     * Getter for the srcDir
     *
     * @return the srcDir
     */
    public File getSrcDir()
    {
        return this.srcDir;
    }

    /**
     * Getter for the verbose
     *
     * @return the verbose
     */
    public boolean isVerbose()
    {
        return this.verbose;
    }

    /**
     * Setter for the diagramEncoding
     *
     * @param diagramEncoding the diagramEncoding to set
     */
    public void setDiagramEncoding( String diagramEncoding )
    {
        this.diagramEncoding = diagramEncoding;
    }

    /**
     * Setter for the diagramLabel
     *
     * @param diagramLabel the diagramLabel to set
     */
    public void setDiagramLabel( String diagramLabel )
    {
        this.diagramLabel = diagramLabel;
    }

    /**
     * Setter for the dotExecutable
     *
     * @param dotExecutable the dotExecutable to set
     */
    public void setDotExecutable( File dotExecutable )
    {
        this.dotExecutable = dotExecutable;
    }

    /**
     * Setter for the encoding
     *
     * @param encoding the encoding to set
     */
    public void setEncoding( String encoding )
    {
        this.encoding = encoding;
    }

    /**
     * Setter for the javadocPath
     *
     * @param javadocPath the relative path or URI to the generated javadoc directory
     */
    public void setJavadocPath( String javadocPath )
    {
        this.javadocPath = javadocPath;
    }

    /**
     * Setter for the javasrcPath
     *
     * @param javasrcPath the relative path or URI to the generated javasrc directory
     */
    public void setJavasrcPath( String javasrcPath )
    {
        this.javasrcPath = javasrcPath;
    }

    /**
     * Setter for the destDir
     *
     * @param destDir the destDir to set
     */
    public void setOut( File destDir )
    {
        this.out = destDir;
    }

    /**
     * Setter for the show.  Possible values are:
     * <ul>
     * <li>public: shows only public classes and members</li>
     * <li>protected: shows only public and protected classes and members</li>
     * <li>package: shows all classes and members not marked private</li>
     * <li>private: shows all classes and members</li>
     * <li>"" (i.e. empty): nothing</li>
     * </ul>
     *
     * @param show the show to set
     */
    public void setShow( String show )
    {
        this.show = show;
    }

    /**
     * Setter for the srcDir
     *
     * @param srcDir the srcDir to set
     */
    public void setSrcDir( File srcDir )
    {
        this.srcDir = srcDir;
    }

    /**
     * Setter for the verbose
     *
     * @param verbose the verbose to set
     */
    public void setVerbose( boolean verbose )
    {
        this.verbose = verbose;
    }

    // ----------------------------------------------------------------------
    // Private
    // ----------------------------------------------------------------------

    /**
     * @return the javadoc output xml file
     */
    private File getJavadocXml()
    {
        if ( this.javadocXml == null )
        {
            this.javadocXml = new File( getOut().getParentFile(), FileUtils.removeExtension( getOut().getName() )
                + ".javadoc.xml" );
            if ( !isVerbose() )
            {
                this.javadocXml.deleteOnExit();
            }
        }

        return this.javadocXml;
    }

    /**
     * @return a temp file for dot file.
     */
    private File getDot()
    {
        if ( this.dot == null )
        {
            this.dot = new File( getOut().getParentFile(), FileUtils.removeExtension( getOut().getName() )
                + ".javadoc.dot" );
            if ( !isVerbose() )
            {
                this.dot.deleteOnExit();
            }
        }

        return this.dot;
    }

    /**
     * @return the xml2dot XSL file.
     * @throws IOException if any
     */
    private File getXml2dot()
        throws IOException
    {
        if ( this.xml2dot == null )
        {
            this.xml2dot = new File( getOut().getParentFile(), FileUtils.removeExtension( getOut().getName() )
                + ".xml2dot.xsl" );
            if ( !isVerbose() )
            {
                this.xml2dot.deleteOnExit();
            }

            InputStream is = getClass().getClassLoader().getResourceAsStream(
                                                                              GenerateUMLDoc.class.getPackage()
                                                                                  .getName().replace( ".", "/" )
                                                                                  + "/xml2dot.xsl" );
            if ( is == null )
            {
                throw new IOException( "This resource doesn't exist." );
            }

            FileOutputStream w = new FileOutputStream( this.xml2dot );

            IOUtil.copy( is, w );

            IOUtil.close( is );

            IOUtil.close( w );
        }

        return this.xml2dot;
    }

    /**
     * Call javadoc tool with the XMLDoclet
     *
     * @throws IOException if Javadoc error
     */
    private void generateJavadocXML()
        throws IOException
    {
        final String defaultExcludes = "**/*~,**/#*#,**/.#*,**/%*%,**/._*,**/CVS,**/CVS/**,"
            + "**/.cvsignore,**/SCCS,**/SCCS/**,**/vssver.scc,**/.svn,**/.svn/**,**/.DS_Store";

        List args = new LinkedList();
        args.add( "-private" );
        args.add( "-sourcepath" );
        args.add( srcDir.getAbsolutePath() );
        if ( StringUtils.isNotEmpty( getEncoding() ) )
        {
            args.add( "-encoding" );
            args.add( getEncoding() );
            args.add( "-xmlencoding" );
            args.add( getEncoding() );
        }
        args.add( "-o" );
        args.add( getJavadocXml().getAbsolutePath() );
        List packages = FileUtils.getDirectoryNames( srcDir, null, defaultExcludes, false );
        for ( Iterator it = packages.iterator(); it.hasNext(); )
        {
            String p = (String) it.next();

            if ( StringUtils.isEmpty( p ) )
            {
                continue;
            }

            if ( FileUtils.getFileNames( new File( srcDir, p ), "*.java", "", false ).isEmpty() )
            {
                continue;
            }

            args.add( StringUtils.replace( p, File.separator, "." ) );
        }

        StringWriter err = new StringWriter();
        StringWriter warn = new StringWriter();
        StringWriter notice = new StringWriter();

        ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();
        try
        {
            Thread.currentThread().setContextClassLoader( XMLDoclet.class.getClassLoader() );
            int exit = Main.execute( "javadoc", new PrintWriter( err ), new PrintWriter( warn ),
                                     new PrintWriter( notice ), XMLDoclet.class.getName(), (String[]) args
                                         .toArray( new String[0] ) );

            if ( exit != 0 )
            {
                throw new IOException( "Error when calling Javadoc: " + err );
            }
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( currentClassLoader );
        }
    }

    /**
     * Apply XSLT to generate dot file from the Javadoc xml
     *
     * @throws IOException if any
     * @throws TransformerException if any
     */
    private void generateJavadocDot()
        throws IOException, TransformerException
    {
        SAXTransformerFactory transformerFactory = (SAXTransformerFactory) TransformerFactory.newInstance();
        if ( !( transformerFactory.getFeature( javax.xml.transform.sax.SAXSource.FEATURE ) && transformerFactory
            .getFeature( javax.xml.transform.stream.StreamResult.FEATURE ) ) )
        {

            throw new TransformerException( "The supplied TrAX transformer library is inadeguate."
                + "Please upgrade to the latest version." );
        }

        Transformer serializer = transformerFactory.newTransformer( new StreamSource( getXml2dot() ) );

        if ( StringUtils.isNotEmpty( getDiagramEncoding() ) )
        {
            serializer.setOutputProperty( OutputKeys.ENCODING, getDiagramEncoding() );
        }

        serializer.setParameter( "now", NOW );
        serializer.setParameter( "diagramEncoding", ( getDiagramEncoding() == null ? "" : getDiagramEncoding() ) );
        serializer.setParameter( "show", ( getShow() == null ? "" : getShow() ) );
        if ( ( StringUtils.isNotEmpty( getJavasrcPath() ) )
            && ( !"/".equals( getJavasrcPath().substring( getJavasrcPath().length() - 1 ) ) ) )
        {
            setJavasrcPath( getJavasrcPath() + "/" );
        }
        serializer.setParameter( "javasrcPath", ( getJavasrcPath() == null ? "" : getJavasrcPath() ) );
        if ( ( StringUtils.isNotEmpty( getJavadocPath() ) )
            && ( !"/".equals( getJavadocPath().substring( getJavadocPath().length() - 1 ) ) ) )
        {
            setJavadocPath( getJavadocPath() + "/" );
        }
        serializer.setParameter( "javadocPath", ( getJavadocPath() == null ? "" : getJavadocPath() ) );
        serializer.setParameter( "diagramLabel", ( getDiagramLabel() == null ? "" : getDiagramLabel() ) );

        serializer.transform( new StreamSource( getJavadocXml() ), new StreamResult( getDot() ) );
    }

    /**
     * Call Graphviz dot to generate images.
     *
     * @throws CommandLineException if any
     * @throws DotNotPresentInPathException if any
     */
    private void generateUmlImage()
        throws CommandLineException, DotNotPresentInPathException
    {
        String outputPath = getOut().getAbsolutePath();
        String format;
        if ( outputPath.lastIndexOf( "." ) != -1 )
        {
            format = outputPath.substring( outputPath.lastIndexOf( "." ) + 1 );
        }
        else
        {
            format = "svg";
        }

        if ( getDotExecutable() == null )
        {
            DotUtil.executeDot( getDot(), getOut() );
        }
        else
        {
            DotUtil.executeDot( getDotExecutable(), getDot(), getOut() );
        }
    }
}
